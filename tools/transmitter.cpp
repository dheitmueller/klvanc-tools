/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <libgen.h>
#include <signal.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <arpa/inet.h>
#if HAVE_CURSES_H
#include <curses.h>
#endif
#include <inttypes.h>

#include "transmitter.h"
#include "db.h"
#include "decklink_portability.h"
#include "v210burn.h"
#include "libklvanc/pixels.h"

pthread_mutex_t			sleepMutex;
pthread_cond_t			sleepCond;
bool				do_exit = false;

const unsigned long		kAudioWaterlevel = 48000;

pthread_t vancmenus_threadId;
static int g_vancmenus_sentMessageCount = 0;

struct db_entry_s {
	char key;
	char title;
	int lineNr;
	char filename[256];
};

void sigfunc(int signum)
{
	if (signum == SIGINT || signum == SIGTERM) {
		do_exit = true;
	}
	pthread_cond_signal(&sleepCond);
}

static inline void le32(uint8_t **p, uint32_t d)
{
    memcpy(*p, &d, sizeof(d));
    (*p) += 4;
}

// Returns the size in bytes of the output v210 buffer
static int write_vanc_msg(uint8_t *dst, const uint16_t *msg, uint16_t msgWordLength)
{
	int v210_len;

	klvanc_y10_to_v210((uint16_t *) msg, dst, msgWordLength);

	/* Figure out the actual size of the resulting v210 buffer */
	v210_len = msgWordLength / 6;
	if (msgWordLength % 6)
		v210_len++;
	v210_len *= 16;

	return v210_len;
}

void hexdump(const unsigned char *p, int lengthBytes)
{
	for (int i = 0; i < lengthBytes; i++)
		fprintf(stderr, "%02x ", *(p + i));
	fprintf(stderr, "\n");
}

static int generate_vanc__64bit_value(uint8_t *dst, uint64_t value)
{
    const size_t len = 6 /* vanc header */ + 8 /* counter data */ + 1 /* csum */;
    const size_t s = ((len + 5) / 6) * 6; /* align for v210 */
    
    uint16_t msg[64];
    uint16_t l = 0;
    
    /* Construct the message */
    msg[l++] = 0x000;
    msg[l++] = 0x3ff;
    msg[l++] = 0x3ff;
    msg[l++] = 0x040;
    msg[l++] = 0x0fe;
    msg[l++] = 0x008;
    msg[l++] = (value >> 56) & 0x0ff;
    msg[l++] = (value >> 48) & 0x0ff;
    msg[l++] = (value >> 40) & 0x0ff;
    msg[l++] = (value >> 32) & 0x0ff;
    msg[l++] = (value >> 24) & 0x0ff;
    msg[l++] = (value >> 16) & 0x0ff;
    msg[l++] = (value >>  8) & 0x0ff;
    msg[l++] = value & 0x0ff;
    
    /* parity bit */
    for (size_t i = 3; i < len - 1; i++)
        msg[i] |= __builtin_parity(msg[i]) ? 0x100 : 0x200;
    
    /* vanc checksum */
    uint16_t vanc_sum = 0;
    for (size_t i = 3; i < len - 1; i++) {
        vanc_sum += msg[i];
        vanc_sum &= 0x1ff;
        //printf("%03x ", msg[i]);
    }
    //printf("\n");

    msg[len - 1] = vanc_sum | ((~vanc_sum & 0x100) << 1);

    /* pad */
    for (size_t i = len; i < s; i++)
        msg[i] = 0x040;

    /* convert to v210 and write into VANC */
    return write_vanc_msg(dst, msg, s);
}

struct vancmenus_context_s {
	TestPattern *generator;
	BMDConfig *config;
	int running;
};

void generate_vanc_msg(struct vancmenus_context_s *ctx, const struct ltn_db_entry_s *e)
{
	unsigned char buf[2048] = { 0 };
	int v210_len;

	v210_len = write_vanc_msg(buf, &e->payload[0], e->payloadWords);

	ctx->generator->sendVANCMessage(e->lineNr, &buf[0], v210_len);
	g_vancmenus_sentMessageCount++;
}

void generate_msg__type_a(struct vancmenus_context_s *ctx, int value)
{
	unsigned char buf[256];
	int len = generate_vanc__64bit_value(&buf[0], value);
	ctx->generator->sendVANCMessage(9, &buf[0], len);
	g_vancmenus_sentMessageCount++;
}

#if HAVE_CURSES_H
static void vancmenus_draw(struct vancmenus_context_s *ctx)
{
	int linenr = 0;

	clear();

	char line_a[160], line_b[160], line_c[160];
	snprintf(line_a, sizeof(line_a), "VANC Transmitter Menus");
	snprintf(line_b, sizeof(line_b), "%s", "");
	snprintf(line_c, sizeof(line_c), "Frames: %" PRIi64 " Sent: %d (%s)", ctx->generator->getScheduledFrameCount(),
		g_vancmenus_sentMessageCount, ctx->generator->m_displayModeName);
	int blen = 76 - (strlen(line_a) + strlen(line_c));
	memset(line_b, 0x20, sizeof(line_b));
	line_b[blen] = 0;

	attron(COLOR_PAIR(1));
	mvprintw(linenr++, 0, "%s%s%s", line_a, line_b, line_c);
	attroff(COLOR_PAIR(1));

	linenr++;
	for (int i = 0; i < ltn_db_get_count(); i++) {
		const struct ltn_db_entry_s *e = ltn_db_get(i);
		mvprintw(linenr++, 2, "%c. %s - Line %d",
			e->key[0],
			e->title,
			e->lineNr);
			
#if 0
		mvprintw(linenr++, 2, "a. KL VANC Proprietary Counter - Value 255 - Line 9");
		mvprintw(linenr++, 2, "b. KL VANC Proprietary Counter - Value 256 - Line 9");
		mvprintw(linenr++, 2, "c. SCTE104 42/07 - Line  9");
		mvprintw(linenr++, 2, "d. SCTE104 ............ ");
#endif
	}

	linenr++;
	attron(COLOR_PAIR(2));
	mvprintw(linenr++, 2, "Commands: Esc to Quit\n");
	attroff(COLOR_PAIR(2));

	time_t now;
	time(&now);
	snprintf(line_a, sizeof(line_a), "LTN Global Communications, Inc.");
	snprintf(line_b, sizeof(line_b), "%s", "");
	snprintf(line_c, sizeof(line_c), "%s", ctime(&now));

	blen = 77 - (strlen(line_a) + strlen(line_c));
	memset(line_b, 0x20, sizeof(line_b));
	line_b[blen] = 0;

	attron(COLOR_PAIR(1));
	linenr++;
	mvprintw(linenr++, 0, "%s%s%s", line_a, line_b, line_c);
	attroff(COLOR_PAIR(1));

	refresh();
}

static void *vancmenus_thread_func(void *p)
{
	struct vancmenus_context_s *ctx = (struct vancmenus_context_s *)p;

	fprintf(stderr, "Entering Interactive VANC Menus\n");
	fprintf(stderr, "ctx->running = %d\n", ctx->running);

	initscr();
	noecho();
	curs_set(0);
	start_color();
	init_pair(1, COLOR_WHITE, COLOR_BLUE);
	init_pair(2, COLOR_CYAN, COLOR_BLACK);
	init_pair(3, COLOR_RED, COLOR_BLACK);

	timeout(0);
	while (ctx->running == true) {
		usleep(100 * 1000);
		vancmenus_draw(ctx);

		int c = getch();
		if (c == 0x1b) {
			kill(getpid(), SIGTERM);
			break;
		} else {
			const struct ltn_db_entry_s *e = ltn_db_get_by_key(c);
			if (!e)
				continue;
			generate_vanc_msg(ctx, e);
		}


	}
	endwin();
	fprintf(stderr, "Exiting Interactive VANC Menus\n");

	return NULL;
}
#endif

static int _main(int argc, char *argv[])
{
	struct vancmenus_context_s vancmenus_ctx = { 0 };
	int				exitStatus = 1;
	TestPattern*	generator = NULL;

	pthread_mutex_init(&sleepMutex, NULL);
	pthread_cond_init(&sleepCond, NULL);

	signal(SIGINT, sigfunc);
	signal(SIGTERM, sigfunc);
	signal(SIGHUP, sigfunc);

	BMDConfig config;
	if (!config.ParseArguments(argc, argv))
	{
		config.DisplayUsage(exitStatus);
		goto bail;
	}

	generator = new TestPattern(&config);
#if HAVE_CURSES_H
	if (config.m_interactiveVANCMenus) {
		ltn_db_load(config.m_vancCfgName);

		vancmenus_ctx.running = true;
		vancmenus_ctx.generator = generator;
		vancmenus_ctx.config = &config;
		pthread_create(&vancmenus_threadId, 0, vancmenus_thread_func, &vancmenus_ctx);
	}
#endif

	if (!generator->Run())
		goto bail;

#if HAVE_CURSES_H
	if (config.m_interactiveVANCMenus) {
		vancmenus_ctx.running = 1;
		usleep(150 * 1000);
	}
#endif

	// All Okay.
	exitStatus = 0;

bail:
	if (generator)
	{
		generator->Release();
		generator = NULL;
	}
	return exitStatus;
}

TestPattern::~TestPattern()
{
}

TestPattern::TestPattern(BMDConfig *config) :
	m_refCount(1),
	m_config(config),
	m_running(false),
	m_deckLink(),
	m_deckLinkOutput(),
	m_displayMode(),
	m_videoFrameBlack(),
	m_videoFrameBars(),
	m_audioBuffer(),
	m_audioSampleRate(bmdAudioSampleRate48kHz),
	m_msg_data_length(0),
	m_frame_num(0),
	m_last_insert(-1)
{
	pthread_mutex_init(&m_msg_mutex, NULL);
	m_displayModeName = NULL;
}

bool TestPattern::Run()
{
	HRESULT							result;
	int								idx;
	bool							success = false;

	IDeckLinkIterator*				deckLinkIterator = NULL;
	DECKLINK_STR displayModeNameTmp = NULL;

	// Get the DeckLink device
	deckLinkIterator = CreateDeckLinkIteratorInstance();
	if (!deckLinkIterator)
	{
		fprintf(stderr, "This application requires the DeckLink drivers installed.\n");
		goto bail;
	}

	idx = m_config->m_deckLinkIndex;

	while ((result = deckLinkIterator->Next(&m_deckLink)) == S_OK)
	{
		if (idx == 0)
			break;
		--idx;

		m_deckLink->Release();
	}

	if (result != S_OK || m_deckLink == NULL)
	{
		fprintf(stderr, "Unable to get DeckLink device %u\n", m_config->m_deckLinkIndex);
		goto bail;
	}

	// Get the output (display) interface of the DeckLink device
	if (m_deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&m_deckLinkOutput) != S_OK)
		goto bail;

	// Get the display mode
	m_displayMode = m_config->GetDeckLinkDisplayMode(m_deckLink, m_config->m_displayMode);
	if (m_displayMode == NULL)
	{
		fprintf(stderr, "Unable to get display mode %x\n", m_config->m_displayMode);
		goto bail;
	}

	// Get display mode name
	result = m_displayMode->GetName(&displayModeNameTmp);
	if (result != S_OK)
	{
		m_displayModeName = (char *)malloc(32);
		snprintf(m_displayModeName, 32, "[%x]", m_config->m_displayMode);
	} else {
		m_displayModeName = DECKLINK_STRDUP(displayModeNameTmp);
		DECKLINK_FREE(displayModeNameTmp);
	}

fprintf(stderr, "Using display mode %s\n", m_displayModeName);
	m_config->DisplayConfiguration();

	// Provide this class as a delegate to the audio and video output interfaces
	m_deckLinkOutput->SetScheduledFrameCompletionCallback(this);
	m_deckLinkOutput->SetAudioCallback(this);

	success = true;

	// Start.
	while (!do_exit)
	{
		StartRunning();
		fprintf(stderr, "Starting playback\n");

		pthread_mutex_lock(&sleepMutex);
		pthread_cond_wait(&sleepCond, &sleepMutex);
		pthread_mutex_unlock(&sleepMutex);
		
		fprintf(stderr, "Stopping playback\n");
		StopRunning();
	}

	printf("\n");

	m_running = false;

bail:
	if (m_displayModeName != NULL)
		free(m_displayModeName);

	if (m_displayMode != NULL)
		m_displayMode->Release();

	if (m_deckLinkOutput != NULL)
		m_deckLinkOutput->Release();

	if (m_deckLink != NULL)
		m_deckLink->Release();

	if (deckLinkIterator != NULL)
		deckLinkIterator->Release();

	return success;
}

void TestPattern::StartRunning()
{
	HRESULT					result;
	unsigned long			audioSamplesPerFrame;

	m_frameWidth = m_displayMode->GetWidth();
	m_frameHeight = m_displayMode->GetHeight();
	m_displayMode->GetFrameRate(&m_frameDuration, &m_frameTimescale);

	// Calculate the number of frames per second, rounded up to the nearest integer.  For example, for NTSC (29.97 FPS), framesPerSecond == 30.
	m_framesPerSecond = (unsigned long)((m_frameTimescale + (m_frameDuration-1))  /  m_frameDuration);

	// Set the video output mode
	result = m_deckLinkOutput->EnableVideoOutput(m_displayMode->GetDisplayMode(), m_config->m_outputFlags);
	if (result != S_OK)
	{
		fprintf(stderr, "Failed to enable video output. Is another application using the card?\n");
		goto bail;
	}

	// Set the audio output mode
	result = m_deckLinkOutput->EnableAudioOutput(bmdAudioSampleRate48kHz, m_config->m_audioSampleDepth, m_config->m_audioChannels, bmdAudioOutputStreamContinuous);
	if (result != S_OK)
	{
		fprintf(stderr, "Failed to enable audio output\n");
		goto bail;
	}

	// Generate one second of audio
	m_audioBufferSampleLength = (unsigned long)((m_framesPerSecond * m_audioSampleRate * m_frameDuration) / m_frameTimescale);
	m_audioBuffer = valloc(m_audioBufferSampleLength * m_config->m_audioChannels * (m_config->m_audioSampleDepth / 8));

	if (m_audioBuffer == NULL)
	{
		fprintf(stderr, "Failed to allocate audio buffer memory\n");
		goto bail;
	}

	// Zero the buffer (interpreted as audio silence)
	memset(m_audioBuffer, 0x0, (m_audioBufferSampleLength * m_config->m_audioChannels * m_config->m_audioSampleDepth / 8));
	audioSamplesPerFrame = (unsigned long)((m_audioSampleRate * m_frameDuration) / m_frameTimescale);

	if (m_config->m_outputVideoPattern == kOutputSignalPipWhite) {
		FillSine(m_audioBuffer, audioSamplesPerFrame, m_config->m_audioChannels, m_config->m_audioSampleDepth);
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalPipBars) {
		FillSine(m_audioBuffer, audioSamplesPerFrame, m_config->m_audioChannels, m_config->m_audioSampleDepth);
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalDrop) {
		FillSine((void*)((unsigned long)m_audioBuffer + (audioSamplesPerFrame * m_config->m_audioChannels * m_config->m_audioSampleDepth / 8)), (m_audioBufferSampleLength - audioSamplesPerFrame), m_config->m_audioChannels, m_config->m_audioSampleDepth);
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalConstant) {
		FillSine((void*)m_audioBuffer, m_audioBufferSampleLength, m_config->m_audioChannels, m_config->m_audioSampleDepth);
	}

	if (m_config->m_outputVideoPattern == kOutputSignalPipWhite) {
		// Generate a frame of black
		if (CreateFrame(&m_videoFrameBlack, FillBlack) != S_OK)
			goto bail;
		if (CreateFrame(&m_videoFrameWhite, FillWhite) != S_OK)
			goto bail;
	} else {
		if (CreateFrame(&m_videoFrameBlack, FillBlack) != S_OK)
			goto bail;
	}

	// Generate a frame of colour bars
	if (CreateFrame(&m_videoFrameBars, FillForwardColourBars) != S_OK)
		goto bail;

	// Begin video preroll by scheduling a second of frames in hardware
	m_totalFramesScheduled = 0;
	m_totalFramesDropped = 0;
	m_totalFramesCompleted = 0;
	for (unsigned i = 0; i < 3 /* m_framesPerSecond */; i++)
		ScheduleNextFrame(true);

	// Begin audio preroll.  This will begin calling our audio callback, which will start the DeckLink output stream.
	m_audioBufferOffset = 0;
	if (m_deckLinkOutput->BeginAudioPreroll() != S_OK)
	{
		fprintf(stderr, "Failed to begin audio preroll\n");
		goto bail;
	}

	m_running = true;

	return;

bail:
	m_running = false;
	exit(1);

	// *** Error-handling code.  Cleanup any resources that were allocated. *** //
	StopRunning();
}

void TestPattern::StopRunning()
{
	// Stop the audio and video output streams immediately
	m_deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
	//
	m_deckLinkOutput->DisableAudioOutput();
	m_deckLinkOutput->DisableVideoOutput();

	if (m_videoFrameBlack != NULL)
		m_videoFrameBlack->Release();
	m_videoFrameBlack = NULL;

	if (m_videoFrameBars != NULL)
		m_videoFrameBars->Release();
	m_videoFrameBars = NULL;

	if (m_audioBuffer != NULL)
		free(m_audioBuffer);
	m_audioBuffer = NULL;

	// Success; update the UI
	m_running = false;
}

void TestPattern::ScheduleNextFrame(bool prerolling)
{
	char frame_label[64];

	if (prerolling == false)
	{
		// If not prerolling, make sure that playback is still active
		if (m_running == false)
			return;
	}

// MMM
	/* Generate a frame .... colorbars or black, something else.... well decode later */
	IDeckLinkMutableVideoFrame *newFrame = NULL;
	int bytesPerPixel = GetBytesPerPixel(m_config->m_pixelFormat);
	int result = m_deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, m_frameWidth * bytesPerPixel, m_config->m_pixelFormat, bmdFrameFlagDefault, &newFrame);
        if (result != S_OK) {
		return;
	}

	uint8_t *srcFramePtr;
	uint8_t *dstFramePtr;
	newFrame->GetBytes((void**)&dstFramePtr);
	if (m_config->m_outputVideoPattern == kOutputSignalPipWhite) {
		if ((m_totalFramesScheduled % m_framesPerSecond) == 0) {
			m_videoFrameWhite->GetBytes((void**)&srcFramePtr);
		} else {
			m_videoFrameBlack->GetBytes((void**)&srcFramePtr);
		}
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalPipBars) {
		if ((m_totalFramesScheduled % m_framesPerSecond) == 0) {
			m_videoFrameBars->GetBytes((void**)&srcFramePtr);
		} else {
			m_videoFrameBlack->GetBytes((void**)&srcFramePtr);
		}
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalDrop) {
		if ((m_totalFramesScheduled % m_framesPerSecond) == 0) {
			m_videoFrameBlack->GetBytes((void**)&srcFramePtr);
		} else {
			m_videoFrameBars->GetBytes((void**)&srcFramePtr);
		}
	} else
	if (m_config->m_outputVideoPattern == kOutputSignalConstant) {
		m_videoFrameBars->GetBytes((void**)&srcFramePtr);
	} else {
		printf("Unsupported output pattern.\n");
		exit(0);
	}

	/* Duplicate original frame into new frame */
	memcpy(dstFramePtr, srcFramePtr, m_frameHeight * (m_frameWidth * bytesPerPixel));

	pthread_mutex_lock(&m_msg_mutex);
	while (m_msg_data_length > 0) {
		IDeckLinkVideoFrameAncillary *vanc;
		if (m_deckLinkOutput->CreateAncillaryData(bmdFormat10BitYUV, &vanc) != S_OK) {
			break;
		}

		unsigned char *vancBuf = 0;
		if (vanc->GetBufferForVerticalBlankingLine(m_msg_line, (void**)&vancBuf) != S_OK) {
			vanc->Release();
			break;
		}

		memcpy(vancBuf, m_msg_data, m_msg_data_length);

		if (newFrame->SetAncillaryData(vanc) != S_OK) {
			vanc->Release();
			break;
		}

		if (m_config->m_pixelFormat == bmdFormat10BitYUV) {
			snprintf(frame_label, sizeof(frame_label), "Injecting VANC (line %d)", m_msg_line);
			v210_burn(dstFramePtr, m_frameWidth, m_frameHeight,  (m_frameWidth * bytesPerPixel),
				  frame_label, 1, 3);
		}

		//printf("Sending vanc %d bytes line %d\n", m_msg_data_length, m_msg_line);
		vanc->Release();
		m_msg_data_length = 0;
		m_last_insert = 0;
	}
	pthread_mutex_unlock(&m_msg_mutex);

        /* Burn frame counters into the video */
	if (m_config->m_pixelFormat == bmdFormat10BitYUV) {
		snprintf(frame_label, sizeof(frame_label), "Frame: %d", m_frame_num);
		m_frame_num++;
		v210_burn(dstFramePtr, m_frameWidth, m_frameHeight, (m_frameWidth * bytesPerPixel),
			  frame_label, 1, 1);
		if (m_last_insert != -1) {
			snprintf(frame_label, sizeof(frame_label), "Last insert: %d", m_last_insert);
			v210_burn(dstFramePtr, m_frameWidth, m_frameHeight, (m_frameWidth * bytesPerPixel),
				  frame_label, 1, 2);
			m_last_insert++;
		}
	}

	if (m_deckLinkOutput->ScheduleVideoFrame(newFrame, (m_totalFramesScheduled * m_frameDuration), m_frameDuration, m_frameTimescale) != S_OK)
		return;

	newFrame->Release();

	m_totalFramesScheduled += 1;
}

void TestPattern::WriteNextAudioSamples()
{
	unsigned int		bufferedSamples;

	// Try to maintain the number of audio samples buffered in the API at a specified waterlevel
	if ((m_deckLinkOutput->GetBufferedAudioSampleFrameCount(&bufferedSamples) == S_OK) && (bufferedSamples < kAudioWaterlevel))
	{
		unsigned int		samplesToEndOfBuffer;
		unsigned int		samplesToWrite;
		unsigned int		samplesWritten;

		samplesToEndOfBuffer = (m_audioBufferSampleLength - m_audioBufferOffset);
		samplesToWrite = (kAudioWaterlevel - bufferedSamples);

		if (samplesToWrite > samplesToEndOfBuffer)
			samplesToWrite = samplesToEndOfBuffer;

		if (m_deckLinkOutput->ScheduleAudioSamples((void*)((unsigned long)m_audioBuffer + (m_audioBufferOffset * m_config->m_audioChannels * m_config->m_audioSampleDepth / 8)), samplesToWrite, 0, 0, &samplesWritten) == S_OK)
		{
			m_audioBufferOffset = ((m_audioBufferOffset + samplesWritten) % m_audioBufferSampleLength);
		}
	}
}

HRESULT TestPattern::CreateFrame(IDeckLinkMutableVideoFrame** frame, void (*fillFunc)(IDeckLinkMutableVideoFrame*))
{
	HRESULT						result;
	int							bytesPerPixel = GetBytesPerPixel(m_config->m_pixelFormat);
	IDeckLinkMutableVideoFrame*	newFrame = NULL;
	IDeckLinkMutableVideoFrame*	referenceFrame = NULL;
	IDeckLinkVideoConversion*	frameConverter = NULL;

	*frame = NULL;

	result = m_deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, m_frameWidth * bytesPerPixel, m_config->m_pixelFormat, bmdFrameFlagDefault, &newFrame);
	if (result != S_OK)
	{
		fprintf(stderr, "Failed to create video frame\n");
		goto bail;
	}

	if (m_config->m_pixelFormat == bmdFormat8BitYUV)
	{
		fillFunc(newFrame);
	}
	else
	{
		// Create a black frame in 8 bit YUV and convert to desired format
		result = m_deckLinkOutput->CreateVideoFrame(m_frameWidth, m_frameHeight, m_frameWidth * 2, bmdFormat8BitYUV, bmdFrameFlagDefault, &referenceFrame);
		if (result != S_OK)
		{
			fprintf(stderr, "Failed to create reference video frame\n");
			goto bail;
		}

		fillFunc(referenceFrame);

		frameConverter = CreateVideoConversionInstance();

		result = frameConverter->ConvertFrame(referenceFrame, newFrame);
		if (result != S_OK)
		{
			fprintf(stderr, "Failed to convert frame\n");
			goto bail;
		}
	}

	*frame = newFrame;
	newFrame = NULL;

bail:
	if (referenceFrame != NULL)
		referenceFrame->Release();

	if (frameConverter != NULL)
		frameConverter->Release();

	if (newFrame != NULL)
		newFrame->Release();

	return result;
}

void TestPattern::PrintStatusLine()
{
	printf("\rscheduled %-16lu completed %-16lu dropped %-16lu\r",
		m_totalFramesScheduled, m_totalFramesCompleted, m_totalFramesDropped);
}

/************************* DeckLink API Delegate Methods *****************************/


HRESULT TestPattern::QueryInterface(REFIID iid, LPVOID *ppv)
{
	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG TestPattern::AddRef()
{
	// gcc atomic operation builtin
	return __sync_add_and_fetch(&m_refCount, 1);
}

ULONG TestPattern::Release()
{
	// gcc atomic operation builtin
	ULONG newRefValue = __sync_sub_and_fetch(&m_refCount, 1);
	if (!newRefValue)
		delete this;
	return newRefValue;
}

HRESULT TestPattern::ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result)
{
	++m_totalFramesCompleted;
	if (!m_config->m_interactiveVANCMenus) {
		PrintStatusLine();
	}

	// When a video frame has been released by the API, schedule another video frame to be output
	ScheduleNextFrame(false);
	return S_OK;
}

HRESULT TestPattern::ScheduledPlaybackHasStopped()
{
	return S_OK;
}

HRESULT TestPattern::RenderAudioSamples(bool preroll)
{
	// Provide further audio samples to the DeckLink API until our preferred buffer waterlevel is reached
	WriteNextAudioSamples();

	if (preroll)
	{
		// Start audio and video output
		m_deckLinkOutput->StartScheduledPlayback(0, 100, 1.0);
	}

	return S_OK;
}

/*****************************************/

void FillSine(void* audioBuffer, unsigned long samplesToWrite, unsigned long channels, unsigned long sampleDepth)
{
	if (sampleDepth == 16)
	{
		short*		nextBuffer;

		nextBuffer = (short*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			short		sample;

			sample = (short)(24576.0 * sin((i * 2.0 * M_PI) / 48.0));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
	else if (sampleDepth == 32)
	{
		int*		nextBuffer;

		nextBuffer = (int*)audioBuffer;
		for (unsigned i = 0; i < samplesToWrite; i++)
		{
			int		sample;

			sample = (int)(1610612736.0 * sin((i * 2.0 * M_PI) / 48.0));
			for (unsigned ch = 0; ch < channels; ch++)
				*(nextBuffer++) = sample;
		}
	}
}

void FillColourBars(IDeckLinkMutableVideoFrame* theFrame, bool reverse)
{
	unsigned int*	nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned int	bars[8] = {0xEA80EA80, 0xD292D210, 0xA910A9A5, 0x90229035, 0x6ADD6ACA, 0x51EF515A, 0x286D28EF, 0x10801080};

	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();

	if (reverse)
	{
		for (unsigned long y = 0; y < height; y++)
		{
			for (unsigned long x = width - 2; x >= 0; x -= 2)
			{
				*(nextWord++) = bars[(x * 8) / width];
			}
		}
	}
	else
	{
		for (unsigned long y = 0; y < height; y++)
		{
			for (unsigned long x = 0; x < width; x += 2)
			{
				*(nextWord++) = bars[(x * 8) / width];
			}
		}
	}
}

void FillWhite(IDeckLinkMutableVideoFrame* theFrame)
{
	unsigned int*	nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned long	wordsRemaining;

	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();

	wordsRemaining = (width * 2 * height) / 4;

	while (wordsRemaining-- > 0)
		*(nextWord++) = 0xEA80EA80;
}

void FillBlack(IDeckLinkMutableVideoFrame* theFrame)
{
	unsigned int*	nextWord;
	unsigned long	width;
	unsigned long	height;
	unsigned long	wordsRemaining;

	theFrame->GetBytes((void**)&nextWord);
	width = theFrame->GetWidth();
	height = theFrame->GetHeight();

	wordsRemaining = (width * 2 * height) / 4;

	while (wordsRemaining-- > 0)
		*(nextWord++) = 0x10801080;
}

int GetBytesPerPixel(BMDPixelFormat pixelFormat)
{
	int bytesPerPixel = 2;

	switch(pixelFormat)
	{
	case bmdFormat8BitYUV:
		bytesPerPixel = 2;
		break;
	case bmdFormat8BitARGB:
	case bmdFormat10BitYUV:
	case bmdFormat10BitRGB:
		bytesPerPixel = 4;
		break;
	}

	return bytesPerPixel;
}

extern "C" int transmitter_main(int argc, char *argv[])
{
        return _main(argc, argv);
}

