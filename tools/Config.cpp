/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <pthread.h>
#include <unistd.h>
#include "Config.h"
#include "decklink_portability.h"

BMDConfig::BMDConfig() :
	m_deckLinkIndex(-1),
	m_displayMode(bmdModeNTSC),
	m_audioChannels(2),
	m_audioSampleDepth(16),
	m_outputFlags(bmdVideoOutputFlagDefault | bmdVideoOutputVANC),
	m_pixelFormat(bmdFormat10BitYUV),
	m_vancCfgName(NULL),
	m_outputVideoPattern(kOutputSignalPipBars),
	m_interactiveVANCMenus(false),
	m_deckLinkName(),
	m_displayModeName()
{
}

BMDConfig::~BMDConfig()
{
	if (m_deckLinkName)
		free(m_deckLinkName);

	if (m_displayModeName)
		free(m_displayModeName);
}

bool BMDConfig::ParseArguments(int argc,  char** argv)
{
	int		ch;
	bool	displayHelp = false;

	while ((ch = getopt(argc, argv, "d:?hc:s:f:a:m:M:n:p:t:v:")) != -1)
	{
		switch (ch)
		{
			case 'd':
				m_deckLinkIndex = atoi(optarg);
				break;

			case 'm':
				m_displayMode  = *(optarg + 0) << 24;
				m_displayMode |= *(optarg + 1) << 16;
				m_displayMode |= *(optarg + 2) <<  8;
				m_displayMode |= *(optarg + 3);
				break;

			case 'c':
				m_audioChannels = atoi(optarg);
				if (m_audioChannels != 2 &&
					m_audioChannels != 8 &&
					m_audioChannels != 16)
				{
					fprintf(stderr, "Invalid argument: Audio Channels must be either 2, 8 or 16\n");
					return false;
				}
				break;

			case 'M':
				m_interactiveVANCMenus = true;
				m_vancCfgName = strdup(optarg);
				break;

			case 's':
				m_audioSampleDepth = atoi(optarg);
				if (m_audioSampleDepth != 16 && m_audioSampleDepth != 32)
				{
					fprintf(stderr, "Invalid argument: Audio Sample Depth must be either 16 bits or 32 bits\n");
					return false;
				}
				break;

			case 'p':
				switch(atoi(optarg))
				{
					case 0: m_pixelFormat = bmdFormat8BitYUV; break;
					case 1: m_pixelFormat = bmdFormat10BitYUV; break;
					case 2: m_pixelFormat = bmdFormat10BitRGB; break;
					default:
						fprintf(stderr, "Invalid argument: Pixel format %d is not valid", atoi(optarg));
						return false;
				}
				break;

			case 'v':
				switch(atoi(optarg))
				{
					case 0: m_outputVideoPattern = kOutputSignalPipBars; break;
					case 1: m_outputVideoPattern = kOutputSignalPipWhite; break;
					case 2: m_outputVideoPattern = kOutputSignalDrop; break;
					case 3: m_outputVideoPattern = kOutputSignalConstant; break;
					default:
						fprintf(stderr, "Invalid argument: Output video pattern %d is not valid", atoi(optarg));
						return false;
				}
				break;

			case '?':
			case 'h':
				displayHelp = true;
		}
	}

	if (m_deckLinkIndex < 0)
	{
		fprintf(stderr, "You must select a device\n");
		DisplayUsage(1);
	}

	if (displayHelp)
		DisplayUsage(0);

	// Get device and display mode names
	IDeckLink *deckLink = GetDeckLink(m_deckLinkIndex);
	if (deckLink != NULL)
	{
		IDeckLinkDisplayMode *displayMode = GetDeckLinkDisplayMode(deckLink, m_displayMode);
		if (displayMode != NULL)
		{
			DECKLINK_STR displayModeNameTmp = NULL;
			displayMode->GetName(&displayModeNameTmp);
			m_displayModeName = DECKLINK_STRDUP(displayModeNameTmp);
			DECKLINK_FREE(displayModeNameTmp);
			displayMode->Release();
		}
		else
		{
			m_displayModeName = strdup("Invalid");
		}

		DECKLINK_STR ModelTmp = NULL;
		deckLink->GetModelName(&ModelTmp);
		m_deckLinkName = DECKLINK_STRDUP(ModelTmp);
		DECKLINK_FREE(ModelTmp);
		deckLink->Release();
	}
	else
	{
		m_deckLinkName = strdup("Invalid");
	}

	return true;
}

IDeckLink* BMDConfig::GetDeckLink(int idx)
{
	HRESULT				result;
	IDeckLink*			deckLink;
	IDeckLinkIterator*	deckLinkIterator = CreateDeckLinkIteratorInstance();
	int					i = idx;

	while((result = deckLinkIterator->Next(&deckLink)) == S_OK)
	{
		if (i == 0)
			break;
		--i;

		deckLink->Release();
	}

	deckLinkIterator->Release();

	if (result != S_OK)
		return NULL;

	return deckLink;
}

IDeckLinkDisplayMode* BMDConfig::GetDeckLinkDisplayMode(IDeckLink* deckLink, BMDDisplayMode mode)
{
	HRESULT							result;
	IDeckLinkDisplayMode*			displayMode = NULL;
	IDeckLinkOutput*				deckLinkOutput = NULL;
	IDeckLinkDisplayModeIterator*	displayModeIterator = NULL;

	result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&deckLinkOutput);
	if (result != S_OK)
		goto bail;

	result = deckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
	if (result != S_OK)
		goto bail;

	while ((result = displayModeIterator->Next(&displayMode)) == S_OK)
	{
		if (displayMode->GetDisplayMode() == mode)
			break;

		displayMode->Release();
	}

	if (result != S_OK)
		goto bail;

bail:
	if (displayModeIterator)
		displayModeIterator->Release();

	if (deckLinkOutput)
		deckLinkOutput->Release();

	return displayMode;
}

void BMDConfig::DisplayUsage(int status)
{
	HRESULT							result = E_FAIL;
	IDeckLinkIterator*				deckLinkIterator = CreateDeckLinkIteratorInstance();
	IDeckLinkDisplayModeIterator*	displayModeIterator = NULL;

	IDeckLink*						deckLink = NULL;
	IDeckLink*						deckLinkSelected = NULL;
	int								deckLinkCount = 0;
	char*							deckLinkName = NULL;

	IDeckLinkOutput*				deckLinkOutput = NULL;

	IDeckLinkDisplayMode*			displayMode;
	char*							displayModeName;

	fprintf(stderr,
		"Usage: TestPattern -d <device id> -m <mode> [OPTIONS]\n"
		"\n"
		"    -d <device id>:\n"
	);

	// Loop through all available devices
	while (deckLinkIterator->Next(&deckLink) == S_OK)
	{
		char *deckLinkName;
		DECKLINK_STR NameStringTmp = NULL;
		result = deckLink->GetModelName(&NameStringTmp);
		if (result == S_OK)
		{
			deckLinkName = DECKLINK_STRDUP(NameStringTmp);
			DECKLINK_FREE(NameStringTmp);
			fprintf(stderr,
				"        %2d: %s%s\n",
				deckLinkCount,
				deckLinkName,
				deckLinkCount == m_deckLinkIndex ? " (selected)" : ""
			);

			free(deckLinkName);
		}

		if (deckLinkCount == m_deckLinkIndex)
			deckLinkSelected = deckLink;
		else
			deckLink->Release();

		++deckLinkCount;
	}

	if (deckLinkCount == 0)
		fprintf(stderr, "        No DeckLink devices found. Is the driver loaded?\n");

	deckLinkName = NULL;

	if (deckLinkSelected != NULL) {
		DECKLINK_STR NameStringTmp = NULL;
		result = deckLinkSelected->GetModelName(&NameStringTmp);
		deckLinkName = DECKLINK_STRDUP(NameStringTmp);
		DECKLINK_FREE(NameStringTmp);
	}
	fprintf(stderr,
		"    -m <mode>: (%s)\n",
		deckLinkName ? deckLinkName : ""
	);

	if (deckLinkName != NULL)
		free(deckLinkName);

	// Loop through all available display modes on the delected DeckLink device
	if (deckLinkSelected == NULL)
	{
		fprintf(stderr, "        No DeckLink device selected\n");
		goto bail;
	}

	result = deckLinkSelected->QueryInterface(IID_IDeckLinkOutput, (void**)&deckLinkOutput);
	if (result != S_OK)
		goto bail;

	result = deckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
	if (result != S_OK)
		goto bail;

	while (displayModeIterator->Next(&displayMode) == S_OK)
	{
		DECKLINK_STR displayModeNameTmp = NULL;
		result = displayMode->GetName(&displayModeNameTmp);
		if (result == S_OK)
		{
			BMDTimeValue frameRateDuration;
			BMDTimeValue frameRateScale;

			displayModeName = DECKLINK_STRDUP(displayModeNameTmp);
			DECKLINK_FREE(displayModeNameTmp);
			displayMode->GetFrameRate(&frameRateDuration, &frameRateScale);

			fprintf(stderr,
				"        %c%c%c%c:  %-20s \t %li x %li \t %g FPS\n",
				displayMode->GetDisplayMode() >> 24,
                                displayMode->GetDisplayMode() >> 16,
                                displayMode->GetDisplayMode() >>  8,
                                displayMode->GetDisplayMode(),
				displayModeName,
				displayMode->GetWidth(),
				displayMode->GetHeight(),
				(double)frameRateScale / (double)frameRateDuration
			);

			free(displayModeName);
		}

		displayMode->Release();
	}

bail:
	fprintf(stderr,
		"    -p <pixelformat>\n"
		"         0:  8 bit YUV (4:2:2)\n"
		"         1:  10 bit YUV (4:2:2) (default)\n"
		"         2:  10 bit RGB (4:4:4)\n"
		"    -v <output video pattern>\n"
		"         0:  PIP Bars (default)\n"
		"         1:  PIP White\n"
		"         2:  Drop\n"
		"         3:  Constant\n"
		"    -c <channels>        Audio Channels (2, 8 or 16 - default is 2)\n"
		"    -s <depth>           Audio Sample Depth (16 or 32 - default is 16)\n"
		"    -M <cfgfile>         Enter VANC message injection menus, using a specific vanc configuration\n"
		"\n"
		"Output a test pattern and start the interactive VANC transmitter UI:\n"
		"\n"
		"   klvanc_transmitter -d0 -m hp59 -M ../vanc-packets/klvanc_transmitter.cfg\n"
	);

	if (deckLinkIterator != NULL)
		deckLinkIterator->Release();

	if (displayModeIterator != NULL)
		displayModeIterator->Release();

	if (deckLinkOutput != NULL)
		deckLinkOutput->Release();

	if (deckLinkSelected != NULL)
		deckLinkSelected->Release();

	exit(status);
}

void BMDConfig::DisplayConfiguration()
{
	fprintf(stderr, "Capturing with the following configuration:\n"
		" - Playback device: %s\n"
		" - Video mode: %s %s\n"
		" - Pixel format: %s\n"
		" - Audio channels: %u\n"
		" - Audio sample depth: %u bit \n",
		m_deckLinkName,
		m_displayModeName,
		(m_outputFlags & bmdVideoOutputDualStream3D) ? "3D" : "",
		GetPixelFormatName(m_pixelFormat),
		m_audioChannels,
		m_audioSampleDepth
	);
}

const char* BMDConfig::GetPixelFormatName(BMDPixelFormat pixelFormat)
{
	switch (pixelFormat)
	{
		case bmdFormat8BitYUV:
			return "8 bit YUV (4:2:2)";
		case bmdFormat10BitYUV:
			return "10 bit YUV (4:2:2)";
		case bmdFormat10BitRGB:
			return "10 bit RGB (4:4:4)";
	}
	return "unknown";
}

